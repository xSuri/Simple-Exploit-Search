# Liblary

from __future__ import division
import requests # req (post/get etc.)
import webbrowser # open site
from tkinter import * #Import gui

import re # sys libs
import sys

from google.cloud import speech # for gspeeach

import pyaudio # import microphone etc.
from six.moves import queue

## GUI

main = Tk()

main.title("Game")
main.geometry("1400x800")

top = Frame(main)
top.pack()

bottom = Frame(main)
bottom.pack()

text_info = "Write CVE, Name or Date exploit  \n"
info = Message(top, text = text_info, width=90)
info.pack()

box = StringVar()

label = Listbox(top, relief=RAISED, width=20, height=4)
label.place(x = 0, y = 0)
label.pack()

label.insert(0, "CVE")
label.insert(1, "Name")
label.insert(2, "Date")

toSearch = Entry(bottom, width=10)
toSearch.pack()

messages = StringVar()


################################################################

# GOOGLE SPEEACH

# Audio recording parameters

RATE = 16000
CHUNK = int(RATE / 4)  # 100ms


class MicrophoneStream(object):


    def __init__(self, rate, chunk):
        self._rate = rate
        self._chunk = chunk

        self._buff = queue.Queue()
        self.closed = True

    def __enter__(self):
        self._audio_interface = pyaudio.PyAudio()
        self._audio_stream = self._audio_interface.open(
            format=pyaudio.paInt16,

            channels=1,
            rate=self._rate,
            input=True,
            frames_per_buffer=self._chunk,

            stream_callback=self._fill_buffer,
        )

        self.closed = False

        return self

    def __exit__(self, type, value, traceback):
        self._audio_stream.stop_stream()
        self._audio_stream.close()
        self.closed = True

        self._buff.put(None)
        self._audio_interface.terminate()

    def _fill_buffer(self, in_data, frame_count, time_info, status_flags):

        self._buff.put(in_data)
        return None, pyaudio.paContinue

    def generator(self):
        while not self.closed:
            chunk = self._buff.get()
            if chunk is None:
                return
            data = [chunk]

            while True:
                try:
                    chunk = self._buff.get(block=False)
                    if chunk is None:
                        return
                    data.append(chunk)
                except queue.Empty:
                    break

            yield b"".join(data)


def listen_print_loop(responses):
    num_chars_printed = 0
    for response in responses:
        if not response.results:
            continue

        result = response.results[0]
        if not result.alternatives:
            continue

        transcript = result.alternatives[0].transcript

        overwrite_chars = " " * (num_chars_printed - len(transcript))

        if not result.is_final:

            num_chars_printed = len(transcript)

        else:
        
            set_text(transcript)

            num_chars_printed = 0
            break

           


def start(event):

    language_code = "pl-PL"  #en-US 

    client = speech.SpeechClient()
    config = speech.RecognitionConfig(
        encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,
        sample_rate_hertz=RATE,
        language_code=language_code,
    )

    streaming_config = speech.StreamingRecognitionConfig(
        config=config, interim_results=True
    )

    with MicrophoneStream(RATE, CHUNK) as stream:
        audio_generator = stream.generator()
        requests = (
            speech.StreamingRecognizeRequest(audio_content=content)
            for content in audio_generator
        )

        responses = client.streaming_recognize(streaming_config, requests)

        listen_print_loop(responses)


################################################################

# To update input

def set_text(text):
    toSearch.delete(0,END)
    toSearch.insert(0,text)
    return

# create new window and show exploit info

def newExploitWindow(resp):


    window = Tk()

    window.title("Result")
    window.geometry("2000x2500")

    topWindow = Frame(window)
    topWindow.pack()

    windowMessages = StringVar()

    windowMsgRateLabel = Message(textvariable=windowMessages, relief=RAISED, width=40 )
    windowMsgRateLabel.pack()

    # scrollbar = Scrollbar(window)
    # scrollbar.pack(side = RIGHT)

################################################################

    def callback(event):
        webbrowser.open_new(event.widget.cget("text"))

    status = resp["response"]["status"]

    if (status != "200"):

        err = "Error " + status
        
        errMsg = Message(topWindow, text = err, width=200)
        errMsg.pack()

    elif (status == "200"):

        res_len = len(resp["result"]) 

        i = 0

        text = "Write CVE, Name or Date exploit  \n"
        txt = Message(topWindow, text = text, width=200)
        txt.pack()

        link = []
        link_exp_db = []
        text_info = []


        while i < res_len:


            curId = resp["result"][i]["entry"]["id"]
            curTitle = resp["result"][i]["entry"]["title"]
            curVulnRiskName = resp["result"][i]["vulnerability"]["risk"]["name"]
            curCveId = resp["result"][i]["source"]["cve"]["id"]
            
            text_info.append('\n\n' + "VulnID: " + curId + "\n" + "VulnName: " + curTitle + "\n" + "VulnRisk: " + curVulnRiskName + "\n" + "Cve: " + curCveId + "\n")

            t_link = r"https://vuldb.com/?id."+curId
            link.append(Label(topWindow, text=t_link, fg="blue", cursor="hand2"))


            change_cve = curCveId.replace("CVE-", "")

            t_cve = r"https://www.exploit-db.com/search?cve="+change_cve #q="+curTitle+r"&cve="+change_cve
            link_exp_db.append(Label(topWindow, text=t_cve, fg="blue", cursor="hand2"))

            i = i + 1

        i = 0

        while i < len(link):

            to_link = link[i]
            to_link_exp_db = link_exp_db[i]
            to_text_info = text_info[i]

            info = Message(topWindow, text = to_text_info, width=200)
            info.pack()

            to_link.pack()
            to_link.bind("<Button-1>", callback)

            to_link_exp_db.pack()
            to_link_exp_db.bind("<Button-1>", callback)



            i = i + 1

    # advanced window


    def advancedWindow(event):
        
        window2 = Tk()

        window2.title("Result Advanced Info")
        window2.geometry("800x600")

        topWindow2 = Frame(window2)
        topWindow2.pack()

    ################################################################

        res_len2 = len(resp["result"])
        text_info2 = ""

        i = 0

        while i < res_len2:

            respVer = "Version: " + resp["response"]["version"]
            respFormat = "Format: " + resp["response"]["format"]
            respStatus = "Status Code: " + resp["response"]["status"]
            respLang = "Language: " + resp["response"]["lang"]
            respRemainingToken = "Tokens: " + str(resp["response"]["remaining"])
            respReqUserId = "UserID: " + resp["request"]["userid"]

            curId = "VulnID: " + resp["result"][i]["entry"]["id"]
            curTitle = "VulnName: " + resp["result"][i]["entry"]["title"]
            curTimeCreate = "Vuln Time Create: " + resp["result"][i]["entry"]["timestamp"]["create"]

            curVulnRiskName = "VulnRisk: " + resp["result"][i]["vulnerability"]["risk"]["name"]
            curCveId = "CVE: " + resp["result"][i]["source"]["cve"]["id"]
            
            text_info2 += ('\n\n' + respVer + "\n" + respFormat + "\n" + curId + "\n" + respStatus + "\n" + respLang + "\n" + respRemainingToken + "\n" + respReqUserId + "\n" + curId + "\n" + curTitle + "\n" + curTimeCreate + "\n" + curVulnRiskName + "\n" + curCveId + "\n")

            i = i + 1

        info2 = Text(topWindow2, width=400, height=700)
        info2.pack()
        info2.insert(INSERT, text_info2)

        sb2 = Scrollbar(window2)
        sb2.pack(side="right", fill="y")
        sb2['command'] = info2.yview

        window2.mainloop()


    advInf = Button(topWindow,text="Advanced Info")
    advInf.bind("<Button-1>", advancedWindow)
    advInf.pack()

    window.mainloop()



# send req to vuldb

def vulreq(payload, payload_value, limit_value):

  url = "https://vuldb.com?api"

  payload = {

    payload : payload_value,
    'limit' : limit_value

  }

  headers = {
    'X-VulDB-ApiKey' : 'API_KEY', #API KEY 
    'Content-type' : 'application/x-www-form-urlencoded',
    'User-Agent' : 'VulDB API Advanced Python Demo Agent'
  }

  response = requests.post(url, headers=headers, data=payload)
  
  r = response.json()

  newExploitWindow(r)



# button search / get params etc.

def req(event):

  choose = str(label.get(ACTIVE))
  param = str(toSearch.get())


  if (choose == "Name"):
    vulreq('search', param, 5)

  elif (choose == "CVE"):
    vulreq('search', param, 5)

  elif (choose == "Date"):
    vulreq('advisory_date', param, 5)


################################################################

# search exploit button

count = Button(bottom,text="Search")
count.bind("<Button-1>", req)
count.pack()

# voice button

voic = Button(bottom,text="Voice")
voic.bind("<Button-1>", start)
voic.pack()


main.mainloop()